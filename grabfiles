#!/bin/bash

# Check if running in zsh or bash and apply appropriate error handling
if [ -n "${ZSH_VERSION:-}" ]; then
	setopt ERR_EXIT # Equivalent to errexit in zsh
elif [ -n "${BASH_VERSION:-}" ]; then
	set -o pipefail # Use pipefail if running in bash
fi

set -o errexit
set -o nounset

# Secure the PATH
export PATH="/usr/local/bin:/usr/bin:/bin"

# Unset potentially harmful environment variables and functions
unset IFS

# Unset functions in a more portable way (compatible with zsh and bash)
if [ -n "${ZSH_VERSION:-}" ]; then
	for fn in $(typeset -f); do
		unset -f "$fn"
	done
elif [ -n "${BASH_VERSION:-}" ]; then
	for fn in $(compgen -A function); do
		unset -f "$fn"
	done
fi

# Disable filename expansion (globbing)
set -o noglob

# Set strict umask for temp files
umask 077

# Allowed directories (configurable via env var with fallback)
ALLOWED_DIRS_ENV="${ALLOWED_DIRS_ENV:-}"
# TODO: Harden environment variable trust, e.g., require opt-in.
if [ -n "$ALLOWED_DIRS_ENV" ]; then
	IFS=':' read -r -a ALLOWED_DIRS <<<"$ALLOWED_DIRS_ENV"
else
	ALLOWED_DIRS=(
		"$HOME/Projects"
		# "$HOME/Jetbrains"
		"$HOME/Documents"
		# "$HOME/PycharmProjects"
		"$HOME/scripts"
		# "$HOME/WebstormProjects"
		# "$HOME/WritersideProjects"
		# "$HOME/vagrant/opensuse-tumbleweed"
		# "$HOME/RustroverProjects"
		"$HOME/.config/nvim"
	)
fi

# Maximum number of files to process
MAX_FILES=100

# Maximum line length for clipboard paths
MAX_LINE_LENGTH=1024

# Function to check if a command exists
command_exists() {
	command -v "$1" >/dev/null 2>&1
}

# Check for required commands with fallbacks
check_dependencies() {
	local required=("git" "xclip" "mktemp" "stat" "file" "realpath")
	for cmd in "${required[@]}"; do
		if ! command_exists "$cmd"; then
			case "$cmd" in
			realpath)
				if command_exists readlink; then
					>&2 echo "Warning: Using 'readlink -f' as fallback for 'realpath'."
				else
					>&2 echo "Error: 'realpath' or 'readlink' required."
					exit 1
				fi
				;;
			stat)
				if command_exists wc; then
					>&2 echo "Warning: Using 'wc -c' as fallback for 'stat -c%s'."
				else
					>&2 echo "Error: 'stat' or 'wc' required for file size."
					exit 1
				fi
				;;
			file)
				>&2 echo "Warning: 'file' command missing; falling back to extension-based binary check (less accurate)."
				;;
			*)
				>&2 echo "Error: Required command '$cmd' is missing."
				exit 1
				;;
			esac
		fi
	done
}

# Ensure xclip is installed
ensure_xclip() {
	if ! command_exists xclip; then
		>&2 echo "Error: xclip is not installed. Please install it using 'sudo apt-get install xclip'."
		exit 1
	fi
}

# Display help message
display_help() {
	cat <<EOF
Usage: grabfiles [OPTIONS] [<repo_path> | <file_paths>...]

Copy the paths and contents of files to the clipboard.

Options:
  -h, --help             Display this help and exit
  --include-hidden       Include hidden files (e.g., .<name>) in the output
  --verbose, -v          Enable verbose debugging output
  --from-clipboard       Read the list of file paths from the clipboard
  --copy-to-file, -ctf   Write the gathered content to a temporary file and copy the file reference to clipboard

Examples:
  grabfiles \$HOME/Projects/myproject
  grabfiles --include-hidden \$HOME/Projects/myproject
  grabfiles --from-clipboard
  grabfiles /path/to/file1 /path/to/file2

Allowed directories (configurable via ALLOWED_DIRS_ENV env var):
EOF
	for dir in "${ALLOWED_DIRS[@]}"; do
		echo "  $dir"
	done
	exit 0
}

# Escape content for markdown, handling triple backticks
escape_content() {
	local content="$1"
	# Escape backticks and use longer delimiter if triple backticks are present
	if printf '%s\n' "$content" | grep -q '```'; then
		printf '%s\n' "$content" | sed 's/`/\\`/g' | sed '1s/^/````\n/; $s/$/\n````/'
	else
		printf '%s\n' "$content" | sed 's/`/\\`/g'
	fi
}

# Sanitize clipboard content
sanitize_clipboard_content() {
	local sanitized=()
	for line in "${file_list[@]}"; do
		# Remove non-printable characters
		line=$(echo "$line" | tr -cd '\11\12\15\40-\176')
		# Whitelist reasonable path characters to prevent injections
		line=$(echo "$line" | sed 's/[^a-zA-Z0-9_./ -()[\]{}@+=,#%]//g')
		# Skip if line exceeds max length
		if ((${#line} > MAX_LINE_LENGTH)); then
			>&2 echo "Warning: Skipping overly long clipboard line: ${line:0:50}..."
			continue
		fi
		sanitized+=("$line")
	done
	file_list=("${sanitized[@]}")
}

# Validate path against allowed directories
validate_path() {
	local path="$1"
	# Check for directory traversal (..)
	if echo "$path" | grep -q '\.\.'; then
		>&2 echo "Warning: Suspicious path '$path' contains '..'. Skipping."
		return 1
	fi

	# Determine resolution command
	local resolve_cmd
	if command_exists realpath; then
		resolve_cmd="realpath -e"
	else
		resolve_cmd="readlink -f"
	fi

	# Resolve path (suppress exit on failure)
	path=$($resolve_cmd "$path" 2>/dev/null) || true
	if [ -z "$path" ]; then
		>&2 echo "Warning: Could not resolve or path does not exist: '$1'. Skipping."
		return 1
	fi

	# Canonicalize allowed dirs for accurate comparison
	local canon_allowed=()
	for dir in "${ALLOWED_DIRS[@]}"; do
		local canon_dir
		canon_dir=$($resolve_cmd "$dir" 2>/dev/null) || true
		if [ -n "$canon_dir" ]; then
			canon_allowed+=("$canon_dir")
		fi
	done

	local is_valid=0
	for allowed in "${canon_allowed[@]}"; do
		if [[ "$path" == "$allowed"* ]]; then
			is_valid=1
			break
		fi
	done
	if ((is_valid == 0)); then
		>&2 echo "Warning: '$path' is not in the list of allowed directories."
		return 1
	fi
	echo "$path"
	return 0
}

# Validate file paths
validate_file_paths() {
	local file_paths=("$@")
	local valid_paths=()
	for file_path in "${file_paths[@]}"; do
		# Skip empty paths
		if [ -z "$file_path" ]; then
			continue
		fi

		local resolved_path
		resolved_path=$(validate_path "$file_path") || true
		if [ -z "$resolved_path" ]; then
			continue
		fi

		if [ ! -f "$resolved_path" ]; then
			>&2 echo "Warning: '$resolved_path' is not a valid file."
			continue
		fi
		valid_paths+=("$resolved_path")
	done
	printf '%s\n' "${valid_paths[@]}"
}

# Function to get the list of files
get_file_list() {
	local from_clipboard="$1"
	local include_hidden="$2"
	local repo_path="$3"
	shift 3
	local args=("$@")
	local file_list=()

	if ((from_clipboard == 1)); then
		# Read file paths from the clipboard
		if ! command_exists xclip; then
			>&2 echo "Error: xclip is required to read from the clipboard."
			exit 1
		fi
		mapfile -t file_list < <(xclip -o -selection clipboard)

		# Sanitize clipboard content
		sanitize_clipboard_content

		# Limit number of files
		if ((${#file_list[@]} > MAX_FILES)); then
			>&2 echo "Error: Too many files in clipboard. Maximum allowed is $MAX_FILES."
			exit 1
		fi

	elif ((${#args[@]} > 0)); then
		# Use file paths provided as arguments
		file_list=("${args[@]}")
	elif [ -n "$repo_path" ]; then
		# Validate repo_path first
		local validated_repo
		validated_repo=$(validate_path "$repo_path") || true
		if [ -z "$validated_repo" ]; then
			>&2 echo "Error: Invalid repository path."
			exit 1
		fi
		repo_path="$validated_repo"

		# Get tracked files from the Git repository
		if ((include_hidden == 1)); then
			mapfile -t file_list < <(git -C "$repo_path" ls-files --)
		else
			mapfile -t file_list < <(git -C "$repo_path" ls-files -- | grep -v '^\.')
		fi
		# Prepend repo_path to each file
		for i in "${!file_list[@]}"; do
			file_list[$i]="$repo_path/${file_list[$i]}"
		done
	else
		>&2 echo "Error: No file paths provided."
		exit 1
	fi

	printf '%s\n' "${file_list[@]}"
}

# Function to URL encode a string
urlencode() {
	local length="${#1}"
	for ((i = 0; i < length; i++)); do
		local c="${1:i:1}"
		case $c in
		[a-zA-Z0-9.~/-]) printf "%s" "$c" ;;
		*) printf '%%%02X' "'$c" ;;
		esac
	done
}

# Function to copy file reference to clipboard using xclip
copy_file_to_clipboard() {
	local file_path="$1"
	local encoded_path
	encoded_path=$(urlencode "$file_path")
	printf "file://%s\r\n" "$encoded_path" | xclip -i -selection clipboard -target text/uri-list
}

# Function to process files
process_files() {
	local copy_to_file="$1"
	local verbose="$2"
	local repo_path="$3"
	shift 3
	local file_paths=("$@")
	local output=""
	local empty_files=()
	local copied_paths=()
	readonly MAX_FILE_SIZE="${MAX_FILE_SIZE:-1048576}"

	for file_path in "${file_paths[@]}"; do
		if [ -z "$file_path" ] || [ ! -f "$file_path" ]; then
			output+="< $(printf '%q' "$file_path") >"$'\n'"\`\`\`"$'\n'"Could not read file"$'\n'"\`\`\`"$'\n\n'
			copied_paths+=("$file_path")
			continue
		fi

		# Check if file is a symlink
		if [ -L "$file_path" ]; then
			>&2 echo "Skipping symlink: $file_path"
			continue
		fi

		# Check file permissions (readable by user)
		if [ ! -r "$file_path" ]; then
			>&2 echo "Skipping non-readable file: $file_path"
			continue
		fi

		# Check file size
		local file_size
		if command_exists stat; then
			file_size=$(stat -c%s "$file_path")
		else
			file_size=$(<"$file_path" wc -c)
		fi

		# Check if file is empty (0 bytes)
		if ((file_size == 0)); then
			empty_files+=("$file_path")
			continue
		fi

		if ((file_size > MAX_FILE_SIZE)); then
			output+="< $(printf '%q' "$file_path") >"$'\n'"\`\`\`"$'\n'"File too large to process"$'\n'"\`\`\`"$'\n\n'
			copied_paths+=("$file_path")
			continue
		fi

		# Skip actual binaries, but allow common text formats like JSON/Lua (even if misdetected as JS)
		local mime_type
		if command_exists file; then
			mime_type=$(file --mime-type -b "$file_path")
		else
			# Fallback to extension-based check (basic)
			# TODO: Enhance fallback with more accurate binary detection.
			local ext="${file_path##*.}"
			case "$ext" in
			txt | md | sh | py | js | json | lua | yaml | xml | csv)
				mime_type="text/plain"
				;;
			*)
				mime_type="application/octet-stream" # Assume binary
				;;
			esac
		fi
		local ext="${file_path##*.}"
		if [[ $mime_type != text/* && $mime_type != application/json && ($mime_type != application/javascript || $ext != "lua") ]]; then
			>&2 echo "Skipping binary file: $file_path (MIME: $mime_type)"
			continue
		fi

		local content
		if content=$(<"$file_path"); then
			# Check for null bytes
			if printf '%s' "$content" | grep -qP '\x00'; then
				>&2 echo "Warning: Null byte found and removed in file: $file_path"
				# Remove null bytes
				content=$(printf '%s' "$content" | tr -d '\0')
			fi

			local escaped_content
			escaped_content=$(escape_content "$content")
			output+="< $(printf '%q' "$file_path") >"$'\n'"\`\`\`"$'\n'"$escaped_content"$'\n'"\`\`\`"$'\n\n'
			copied_paths+=("$file_path")
		else
			output+="< $(printf '%q' "$file_path") >"$'\n'"\`\`\`"$'\n'"Error reading file content"$'\n'"\`\`\`"$'\n\n'
			copied_paths+=("$file_path")
		fi
	done

	# Add empty files list to clipboard output
	if ((${#empty_files[@]} > 0)); then
		output+="# Empty Files (0 bytes)"$'\n\n'
		for empty_file in "${empty_files[@]}"; do
			output+="- $empty_file"$'\n'
			copied_paths+=("$empty_file")
		done
		output+=$'\n'
	fi

	if [ -z "$output" ] && ((${#empty_files[@]} == 0)); then
		>&2 echo "No files to process."
	else
		if ((verbose == 1)); then
			echo "Verbose debugging output:"
			printf '%s\n' "$output"
			echo "Debug: Processed ${#file_paths[@]} files."
		fi
		if ((copy_to_file == 1)); then
			local temp_dir="$HOME/.grabfiles_tmp"
			mkdir -p "$temp_dir" # Create if not exists
			chmod 700 "$temp_dir"
			local temp_file
			temp_file=$(mktemp "$temp_dir/grabfiles_output.XXXXXX.md") # No user-controlled prefix
			printf '%s' "$output" >"$temp_file"
			copy_file_to_clipboard "$temp_file"
			if command_exists clipnotify; then
				(clipnotify && rm -f "$temp_file") &
			else
				>&2 echo "Warning: clipnotify not installed; temp file will auto-delete after 5 minutes."
				(sleep 300 && rm -f "$temp_file") &
			fi
			echo "The output has been written to $temp_file and its reference copied to your clipboard."
			echo "Note: Temp file will be deleted automatically (via clipnotify or timeout)."
		else
			printf '%s' "$output" | xclip -selection clipboard
			echo "The file paths and contents have been copied to your clipboard."
		fi
		if ((${#empty_files[@]} > 0)); then
			>&2 echo "Note: ${#empty_files[@]} empty file(s) added to clipboard output."
		fi
		if ((${#copied_paths[@]} > 0)); then
			echo "Paths of copied files:"
			for path in "${copied_paths[@]}"; do
				echo "$path"
			done
		fi
	fi
}

main() {
	ensure_xclip
	check_dependencies

	if [ "$(id -u)" -eq 0 ]; then
		>&2 echo "Error: Do not run this script as root."
		exit 1
	fi

	local INCLUDE_HIDDEN=0
	local VERBOSE=0
	local FROM_CLIPBOARD=0
	local COPY_TO_FILE=0
	local repo_path=""
	local positional_args=()

	while [[ "$#" -gt 0 ]]; do
		case "$1" in
		-h | --help)
			display_help
			;;
		--include-hidden)
			INCLUDE_HIDDEN=1
			shift
			;;
		--verbose | -v)
			VERBOSE=1
			shift
			;;
		--from-clipboard)
			FROM_CLIPBOARD=1
			shift
			;;
		--copy-to-file | -ctf)
			COPY_TO_FILE=1
			shift
			;;
		*)
			positional_args+=("$1")
			shift
			;;
		esac
	done

	if ((FROM_CLIPBOARD == 0)) && ((${#positional_args[@]} == 0)); then
		>&2 echo "Error: No file paths or repository path provided."
		>&2 echo "Try '$0 --help' for more information."
		exit 1
	fi

	local file_list=()
	if ((FROM_CLIPBOARD == 1)); then
		mapfile -t file_list < <(get_file_list "$FROM_CLIPBOARD" "$INCLUDE_HIDDEN" "" "${positional_args[@]}")
	elif [ -d "${positional_args[0]}" ] && [ -d "${positional_args[0]}/.git" ]; then
		repo_path="${positional_args[0]}"
		mapfile -t file_list < <(get_file_list "$FROM_CLIPBOARD" "$INCLUDE_HIDDEN" "$repo_path")
	else
		file_list=("${positional_args[@]}")
	fi

	# Validate the file paths
	mapfile -t valid_file_paths < <(validate_file_paths "${file_list[@]}")

	if ((${#valid_file_paths[@]} == 0)); then
		>&2 echo "No valid files to process."
		exit 1
	fi

	process_files "$COPY_TO_FILE" "$VERBOSE" "$repo_path" "${valid_file_paths[@]}"
}

# TODO: Improve support for Zsh and other shells.

main "$@"
